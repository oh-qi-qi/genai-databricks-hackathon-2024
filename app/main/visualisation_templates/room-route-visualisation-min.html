<!doctype html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto:400,700&subset=latin,cyrillic-ext" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><script src="https://d3js.org/d3.v6.min.js"></script><script src="https://unpkg.com/d3-v6-tip@1.0.6/build/d3-v6-tip.js"></script><title>Room Route Graph Visualization</title><style>.graph-container{margin:auto;}div#data_vis_display{overflow:auto}.d3-tip{line-height:1.4;padding:12px;background:rgba(0,0,0,.8);color:#fff;border-radius:2px;pointer-events:none!important;font-size:12px;font-family:sans-serif;}svg{border:1px solid #000}.legend{font-size:12px;font-family:sans-serif}.route-label{font-size:10px;font-family:sans-serif;font-weight:700;fill:#fff;text-anchor:middle;dominant-baseline:central}</style></head><body><div class="graph-container"><div id="data_vis_display"></div></div><script> $(document).ready(function() { var graph = '''path_graph_json'''; const width = 800, height = 550, circle_radius = 40; const svg = d3.select("#data_vis_display").append("svg").attr("viewBox", `0 0 ${width} ${height}`); const nodeColorScale = d3 .scaleOrdinal() .domain(["source", "destination", "intermediate"]) .range(["#1f77b4", "#2ca02c", "#ff7f0e"]); const tip = d3 .tip() .attr("class", "d3-tip") .offset([-10, 0]) .html(function(event, d) { if (d.route) { return `<strong>Route ${d.route}</strong><br> Path: ${d.path.join("\u2192")}<br> Distance: ${d.route_distance.toFixed(2)}m`; } else { return `<strong>${d.name}</strong><br> Type: ${d.type}<br> Area: ${d.area}<br> Level: ${d.level}`; } }); svg.call(tip); svg.append("defs") .append("marker") .attr("id", "end") .attr("viewBox", "0 -5 10 10") .attr("refX", 10) .attr("markerWidth", 6) .attr("markerHeight", 6) .attr("orient", "auto") .append("path") .attr("d", "M0,-5L10,0L0,5") .style("fill", "#666") .style("stroke", "none"); const simulation = d3 .forceSimulation() .force( "link", d3 .forceLink() .id((d) => d.id) .distance(200) ) .force("charge", d3.forceManyBody().strength(-500)) .force("center", d3.forceCenter(width / 2, height / 2)) .force("collide", d3.forceCollide().radius(circle_radius * 1.5)); const linkGroup = svg.append("g").attr("class", "links"); const nodeGroup = svg.append("g").attr("class", "nodes"); function getNodeTypeFromLinks(nodeId, links) { let sourceCount = 0; let targetCount = 0; links.forEach((link) => { if (link.source === nodeId) { sourceCount++; } if (link.target === nodeId) { targetCount++; } }); console.log(nodeId); if (sourceCount === 0 && targetCount > 0) { return "destination"; } else if (sourceCount > 0 && targetCount === 0){ return "source"; } else if (sourceCount > 0 && targetCount > 0) { return "intermediate"; } return "unknown"; } function computeLinkNumbers(links) { let linkGroups = {}; links.forEach(function(d) { let sourceId = typeof d.source === "object" ? d.source.id : d.source; let targetId = typeof d.target === "object" ? d.target.id : d.target; let key = [sourceId, targetId].sort().join(","); if (!linkGroups[key]) { linkGroups[key] = []; } linkGroups[key].push(d); }); for (let key in linkGroups) { let group = linkGroups[key]; group.forEach(function(link, i) { link.linknum = i; link.totalLinks = group.length; }); } } computeLinkNumbers(graph.links); function update() { const link = linkGroup.selectAll("g").data(graph.links).join("g"); link.append("path") .attr("fill", "none") .attr("stroke", "#999") .attr("stroke-width", 2) .attr("marker-end", "url(#end)"); const labelGroup = link.append("g").attr("class", "label"); labelGroup .append("rect") .attr("width", 50) .attr("height", 30) .attr("rx", 10) .attr("ry", 10) .attr("fill", "#fff") .attr("stroke", "#999"); labelGroup .append("text") .attr("class", "route-label") .attr("dy", ".35em") .style("font-size", "12px") .style("font-weight", "bold") .style("fill", "#000") .attr("text-anchor", "middle") .text((d) => `Route ${d.route}`) .on("mouseover", tip.show) .on("mouseout", tip.hide); const node = nodeGroup .selectAll("g") .data(graph.nodes) .join("g") .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended)) .on("mouseover", tip.show) .on("mouseout", tip.hide); node.append("circle") .attr("r", circle_radius) .attr("fill", (d) => nodeColorScale(getNodeTypeFromLinks(d.id, graph.links))); node.append("text") .attr("text-anchor", "middle") .attr("dominant-baseline", "central") .attr("font-family", "FontAwesome") .style("fill", "white") .each(function(d) { const textElement = d3.select(this); const icon = getIconFromName(d.name); textElement.append("tspan").attr("font-size", "20px").attr("dy", "-0.5em").text(icon); const words = d.name.split(/\s+/); let lineHeight = 1.1; words.forEach((word, i) => { textElement .append("tspan") .attr("x", 0) .attr("dy", i ? `${lineHeight}em` : "1.5em") .attr("font-size", "10px") .text(word); }); }); simulation.nodes(graph.nodes).on("tick", ticked); simulation.force("link").links(graph.links); simulation.alpha(1).restart(); const legend = svg.append("g").attr("class", "legend").attr("transform", "translate(20,20)"); const legendData = [{ type: "Source", color: nodeColorScale("source") }, { type: "Destination", color: nodeColorScale("destination") }, { type: "Intermediate", color: nodeColorScale("intermediate") } ]; const legendItems = legend .selectAll(".legend-item") .data(legendData) .enter() .append("g") .attr("class", "legend-item") .attr("transform", (d, i) => `translate(0,${i * 20})`); legendItems .append("rect") .attr("width", 18) .attr("height", 18) .style("fill", (d) => d.color); legendItems .append("text") .attr("x", 24) .attr("y", 9) .attr("dy", ".35em") .text((d) => d.type) .style("font-size", "12px"); } function manhattanDistance(point1, point2) { return Math.abs(point1.x - point2.x) + Math.abs(point1.y - point2.y); } function linkPath(d) { const dx = d.target.x - d.source.x; const dy = d.target.y - d.source.y; const dr = Math.sqrt(dx * dx + dy * dy); const angle = Math.atan2(dy, dx); const totalLinks = d.totalLinks; const linknum = d.linknum; const angleOffset = (linknum - (totalLinks - 1) / 2) * (Math.PI / 12); const sourceAngle = angle + angleOffset; const targetAngle = angle + Math.PI + angleOffset; const sourceX = d.source.x + Math.cos(sourceAngle) * circle_radius; const sourceY = d.source.y + Math.sin(sourceAngle) * circle_radius; const targetX = d.target.x + Math.cos(targetAngle) * circle_radius; const targetY = d.target.y + Math.sin(targetAngle) * circle_radius; const curvature = 0.25 * (linknum - (totalLinks - 1) / 2); const path = `M${sourceX},${sourceY}A${dr * Math.abs(curvature)},${dr * Math.abs(curvature)} 0 0,${ curvature > 0 ? 1 : 0 } ${targetX},${targetY}`; return path; } function ticked() { linkGroup.selectAll("g").each(function(d) { const link = d3.select(this); const path = linkPath(d); const pathElement = link.select("path").attr("d", path).node(); if (pathElement) { const totalLength = pathElement.getTotalLength(); const midPoint = pathElement.getPointAtLength(totalLength / 2); link.select(".label").attr("transform", `translate(${midPoint.x},${midPoint.y})`); link.select(".label rect").attr("x", -25).attr("y", -15); link.select(".label text").attr("x", 0).attr("y", 0); } }); nodeGroup.selectAll("g").attr("transform", (d) => `translate(${d.x},${d.y})`); } function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; } function dragged(event, d) { d.fx = event.x; d.fy = event.y; } function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; } function getIconFromName(name) { const iconMap = { Staircase: "\ue289", Computer: "\ue4e5", Electrical: "\uf0eb", Washroom: "\uf7d8", Meeting: "\ue537", Training: "\uf51c", Hallway: "\uf557", Smoking: "\uf48d", Security: "\ue54a", Prayer: "\uf683", Mechanical: "\uf0ad", Cafeteria: "\uf0f4", Outside: "\uf850", Loading: "\uf4de" }; const trimmedName = name.trim().toLowerCase(); const matchingKeyword = Object.keys(iconMap).find((keyword) => trimmedName.includes(keyword.toLowerCase()) ); return iconMap[matchingKeyword] || "\uf0db"; } update(); }); </script> </body> </html>