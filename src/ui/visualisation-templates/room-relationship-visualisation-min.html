<!DOCTYPE html> <html lang="en"> <head> <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto:400,700&subset=latin,cyrillic-ext" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" rel="stylesheet"><script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><script src="https://d3js.org/d3.v6.min.js"></script><script src="https://unpkg.com/d3-v6-tip@1.0.6/build/d3-v6-tip.js"></script><title>Room Relationship Graph Visualization</title> <style> .graph-container { margin: auto; width: 90%; padding: 10px; } div#data_vis_display { overflow: auto; } .d3-tip { font-family: Arial, Helvetica, sans-serif; line-height: 1.4; padding: 20px; pointer-events: none !important; color: #203d5d; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); background-color: #fff; border-radius: 4px; } svg { border: 1px solid black; } .legend { font-size: 14px; font-family: Arial, sans-serif; } #selectButton{ margin-bottom:10px; } </style> </head> <body> <div class="graph-container"> <div class="input-field col l2 m3 s12"> <select id="selectButton"></select> </div> <div id="data_vis_display"></div> <div id="tooltip"></div> </div> <script> $(document).ready(function() { var graph = '''room_graph_data_json'''; const margin = { top: 0, right: 200, bottom: 0, left: 0 }; const width = 1200, height = 700, circle_radius = 40; const svg = d3.select("#data_vis_display").append("svg").attr("viewBox", `0 0 ${width} ${height}`); const buildingLevels = Array.from(new Set(graph.nodes.map((d) => d.level).sort((a, b) => parseFloat(a) - parseFloat(b)))); const levelOptions = ["Show All", ...buildingLevels]; d3.select("#selectButton") .selectAll("option") .data(levelOptions) .enter() .append("option") .text((d) => d) .attr("value", (d) => d); d3.select("#selectButton").on("change", function() { update(this.value); }); const colorScaleLevel = d3.scaleOrdinal().domain(buildingLevels).range(d3.schemeCategory10); svg.append("g") .attr("class", "legend") .attr("transform", `translate(${width - margin.right},20)`) .call( d3 .legendColor() .labels(buildingLevels.map((l, i) => `${l}`)) .title("Level") .scale(colorScaleLevel) ); svg.append("defs") .append("marker") .attr("id", "end") .attr("viewBox", "0 -5 10 10") .attr("refX", 10) .attr("markerWidth", 6) .attr("markerHeight", 6) .attr("orient", "auto") .append("path") .attr("d", "M0,-5L10,0L0,5") .style("fill", "#666") .style("stroke", "none"); const tip = d3 .tip() .attr("class", "d3-tip") .html(function(event, d) { return ( "<strong>Name:</strong> <span>" + d.name + "</span>" + "<br><strong>Type:</strong> <span>" + d.type + "</span>" + "<br><strong>Area:</strong> <span>" + d.area + "</span>" ); }); svg.call(tip); const simulation = d3 .forceSimulation() .force("x", d3.forceX(width / 2).strength(0.15)) .force("y", d3.forceY(height / 2).strength(0.3)) .force( "link", d3 .forceLink() .id((d) => d.id) .distance(100) ) .force("charge", d3.forceManyBody().strength(-200)) .force("collide", d3.forceCollide(circle_radius + 20).strength(0.8)) .on("tick", ticked); const nodeGroup = svg.append("g").attr("class", "nodes"); const linkGroup = svg.append("g").attr("class", "links"); update(levelOptions[0]); function update(selectedLevel) { const filteredNodes = selectedLevel === "Show All" ? graph.nodes : graph.nodes.filter((d) => d.level === selectedLevel); const nodeIds = new Set(filteredNodes.map((d) => d.id)); const filteredLinks = graph.links.filter( (d) => nodeIds.has(d.source.id || d.source) && nodeIds.has(d.target.id || d.target) ); const link = linkGroup .selectAll("path") .data(filteredLinks, (d) => d.source.id + "-" + d.target.id); link.exit().remove(); link.enter() .append("path") .attr("class", "links") .attr("stroke-width", 1) .attr("stroke", "#666") .attr("fill", "none") .attr("marker-end", "url(#end)") .merge(link); const node = nodeGroup.selectAll("g").data(filteredNodes, (d) => d.id); node.exit().remove(); const nodeEnter = node .enter() .append("g") .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended)); nodeEnter .append("circle") .attr("r", circle_radius) .style("fill", (d) => colorScaleLevel(d.level)); nodeEnter .append("text") .attr("text-anchor", "middle") .attr("dominant-baseline", "central") .attr("font-family", "FontAwesome") .style("fill", "white") .each(function(d) { const textElement = d3.select(this); const icon = d.type === "Room" ? getIconFromName(d.name) : ""; textElement .append("tspan") .attr("font-size", "12px") .attr("dy", "-1.5em") .text(icon); const words = d.name.split(/\s+/); let line = [], lineHeight = 1.2, tspan = textElement .append("tspan") .attr("x", 0) .attr("dy", "2.1em") .attr("font-size", "8px"); words.forEach((word) => { line.push(word); tspan.text(line.join(" ")); if (tspan.node().getComputedTextLength() > 2 * (circle_radius - 8)) { line.pop(); tspan.text(line.join(" ")); line = [word]; tspan = textElement .append("tspan") .attr("x", 0) .attr("dy", lineHeight + "em") .attr("font-size", "8px") .text(word); } }, this); }); nodeEnter.on("mouseover", tip.show).on("mouseout", tip.hide); node.merge(nodeEnter); simulation.nodes(filteredNodes); simulation.force("link").links(filteredLinks); simulation.alpha(1).restart(); } function ticked() { nodeGroup.selectAll("g").attr("transform", (d) => `translate(${d.x},${d.y})`); linkGroup.selectAll("path").attr("d", linkPath); } function linkPath(d, i) { const dx = d.target.x - d.source.x; const dy = d.target.y - d.source.y; const dr = Math.sqrt(dx * dx + dy * dy); const curvatureOffset = (i % 10) * 10; const scaleSource = circle_radius / dr; const scaleTarget = circle_radius / dr; const [sourceX, sourceY] = [d.source.x + dx * scaleSource, d.source.y + dy * scaleSource]; const [targetX, targetY] = [d.target.x - dx * scaleTarget, d.target.y - dy * scaleTarget]; return dr > circle_radius * 2 ? `M${sourceX},${sourceY}A${dr + curvatureOffset},${dr + curvatureOffset} 0 0,1 ${targetX},${targetY}` : `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`; } function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.2).restart(); d.fx = d.x; d.fy = d.y; } function dragged(event, d) { d.fx = event.x; d.fy = event.y; } function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; } function getIconFromName(name) { const iconMap = { Staircase: "\ue289", Computer: "\ue4e5", Electrical: "\uf0eb", Washroom: "\uf7d8", Meeting: "\ue537", Training: "\uf51c", Hallway: "\uf557", Smoking: "\uf48d", Security: "\ue54a", Prayer: "\uf683", Mechanical: "\uf0ad", Cafeteria: "\uf0f4", Outside: "\uf850", Loading: "\uf4de" }; const trimmedName = name.trim().toLowerCase(); const matchingKeyword = Object.keys(iconMap).find((keyword) => trimmedName.includes(keyword.toLowerCase()) ); return iconMap[matchingKeyword] || "\uf0db"; } }); </script> </body> </html>